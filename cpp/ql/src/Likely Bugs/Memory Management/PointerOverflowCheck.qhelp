<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">
<qhelp>
<overview>
<p>
When checking for out-of-range pointer values, we might write tests like
<code>p + a &lt; p</code> and check if the value "wraps around".
Such a test is wrong in that it relies on the overflow of <code>p + a</code>,
which has undefined behavior. In fact, many optimizing compilers will remove
<code>p + a &lt; p</code> altogether and replace it with the value <code>0</code> 
(<code>false</code>).  Conversely, should <code>p + a</code> <i>not</i> overflow,
the programmer may erroneously assume that the memory location <code>p + a</code>
is accessible to the program, even though it may be inaccessible (protected by
the operating system) or nonexistent; writing to such memory, if allowed, can
lead to memory corruption. 
</p>
</overview>
<recommendation>
<p>
To check whether an index <code>a</code> is less than the length of an array, 
simply compare these two numbers as unsigned integers: <code>a &lt; ARRAY_LENGTH</code>. 
If the length of the array is defined as the difference between two pointers 
<code>p</code> and <code>p_end</code>, write <code>a &lt; p_end - p</code>.
If a is <code>signed</code>, cast it to <code>unsigned</code> 
in order to guard against negative <code>a</code>. For example, write 
<code>(size_t)a &lt; p_end - p</code>.</p>
</recommendation>
<example>
<p>
In the first example, an index <code>a</code>is being added to a pointer <code>p</code>
to an array with elements of type <code>T</code>.  Since we are not provided a
separate pointer pointing to the end of the array, we fall back 
on a check for address "wrap-around" to see if <code>p + a</code> points at 
valid memory.  This scheme does not work, unfortunately, since the
value of <code>p + a</code> is undefined if it points at invalid memory (for 
example, outside our array).  Even if <code>p + a</code> were to point to 
some accessible memory location, it would almost certainly lie 
<i>outside</i> the bounds of the array.
</p>
<sample src="PointerOverflowCheck-bad.cpp" />
<p>
The next example shows how to properly check for an out-of-range pointer.
In order to do so, we need to obtain the value <code>ptr_end</code>
representing the end of the array (or the address immediately past
the end).  We can then express the condition <code>p + a &lt; p_end</code> as a
difference of two pointers, even if <code>p + a</code> happens to be undefined. 
</p>
<sample src="PointerOverflowCheck-good.cpp" />
</example>
<references>
<li><a href="https://blog.regehr.org/archives/1395">Pointer Overflow Checking [Embedded in Academia]</a></li>
<li><a href="https://lwn.net/Articles/278137/">GCC and pointer overflows [LWN]</a></li>
</references>
</qhelp>
