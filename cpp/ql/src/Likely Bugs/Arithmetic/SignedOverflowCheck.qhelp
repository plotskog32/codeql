<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">
<qhelp>
<overview>
<p>
Testing for <code>signed</code> integer overflow by adding a
value to a variable and then comparing the result to that variable
is not defined by the C or C++ standards.  The comparison may
produce an unintended result, or may be deleted by the compiler
entirely.
</p>
</overview>
<recommendation>
<p>
Make sure that the comparison in question uses <i>unsigned</i> values.
</p>
</recommendation>
<example>
<p>
In the following example, even though <code>delta</code> has been declared
<code>unsigned short</code>, C/C++ type promotion rules require that its
type is promoted to the larger type used in the addition and comparison,
namely a <code>signed int</code>.  As a result, the entire expression is
evaluated using <code>signed</code> integers and may overflow, and hence
is undefined.
</p>
<sample src="SignedOverflowCheck-bad1.cpp" />
<p>
In the following example, even though both <code>n</code> and <code>delta</code>
have been declared <code>unsigned short</code>, both are promoted to 
<code>signed int</code> prior to addition.  Because we started out with the
narrower <code>short</code> type, the addition is guaranteed not to overflow
and is therefore defined.  But the fact that <code>n1 + delta</code> never 
overflows means that the condition <code>n1 + delta &lt; n1</code> will never
hold true, which likely is not what the programmer intended. (see also the
<code>BadArithmeticOverflow.Check.ql</code> query).
</p>
<sample src="SignedOverflowCheck-bad2.cpp" />
<p>
The following example builds upon the previous one.  Again, we have two
<code>unsigned short</code> values getting promoted to a wider type.  However,
since <code>delta</code> is explicitly cast to an <code>unsigned</code> type,
<code>n1</code> (on both sides of the comparison) is promoted to
<code>unsigned int</code> as well.  Since we are now operating on
<code>unsigned</code> values, the overflow check is defined and supported by
standard C/C++.
</p>
<sample src="SignedOverflowCheck-good1.cpp" />
<p>
In the next example, a value of type <code>signed int</code> is
added to a value of type <code>unsigned int</code>.  Because
the types are of the same size, C/C++ conversion rules dictate that
<code>unsigned int</code> is chosen as the overall type of the addition
operation. The entire expression is evaluated using <code>unsigned</code>
values, which is allowed and defined behavior per the C/C++ standard.
</p>
<sample src="SignedOverflowCheck-good2.cpp" />
</example>
<references>
<li><a href="http://c-faq.com/expr/preservingrules.html">comp.lang.c FAQ list Â· Question 3.19 (Preserving rules)</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data">INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data</a></li>
</references>
</qhelp>
