<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">
<qhelp>
<overview>
<p>
When checking for integer overflow, one often writes tests like
<code>a + b &lt; a</code>.  This works fine if <code>a</code> or
<code>b</code> are unsigned integers, since any overflow in the addition
will cause the value to simply "wrap around".  However, using
<i>signed</i> integers is problematic because signed overflows have undefined
behavior according to the C and C++ standards.  If the addition overflows
and has an undefined result, the comparison will likewise be undefined;
it may produce an unintended result, or may be deleted entirely by an
optimizing compiler.
</p>
</overview>
<recommendation>
<p>
When checking for overflow by adding two values, first make sure that <code>a</code>
or <code>b</code> are (converted into) unsigned values, unless it is
certain that the signed addition cannot overflow.
</p>
</recommendation>
<example>
<p>
In the following example, even though <code>delta</code> has been declared
<code>unsigned short</code>, C/C++ type promotion rules require that its
type is promoted to the larger type used in the addition and comparison,
namely a <code>signed int</code>.  Addition is performed on 
signed integers, and may have undefined behavior if an overflow occurs.
As a result, the entire (comparison) expression may also have an undefined
result.
</p>
<sample src="SignedOverflowCheck-bad1.cpp" />
<p>
In the following example, even though both <code>n</code> and <code>delta</code>
have been declared <code>unsigned short</code>, both are promoted to 
<code>signed int</code> prior to addition.  Because we started out with the
narrower <code>short</code> type, the addition is guaranteed not to overflow
and is therefore defined.  But the fact that <code>n1 + delta</code> never 
overflows means that the condition <code>n1 + delta &lt; n1</code> will never
hold true, which likely is not what the programmer intended. (see also the
<code>BadArithmeticOverflow.Check.ql</code> query).
</p>
<sample src="SignedOverflowCheck-bad2.cpp" />
<p>
The following example builds upon the previous one.  Again, we have two
<code>unsigned short</code> values getting promoted to a wider type, resulting
in a comparison that always succeeds (since there is no overflow).  To
test whether we have an <code>unsigned short</code> overflow, we cast the
left-hand side to it, causing the right-hand side to remain an <code>unsigned
short</code> as well.
</p>
<sample src="SignedOverflowCheck-good1.cpp" />
<p>
In the next example, we have two <code>signed int</code> values that we
wish to add together.  Adding them "as-is" opens the possibility of
a signed integer overflow, the results of which are undefined.
By casting one of the operands to <code>unsigned</code>, the entire 
expression is evaluated using <code>unsigned</code>
values, which is defined behavior per the C/C++ standard.
</p>
<sample src="SignedOverflowCheck-good2.cpp" />
</example>
<references>
<li><a href="http://c-faq.com/expr/preservingrules.html">comp.lang.c FAQ list Â· Question 3.19 (Preserving rules)</a></li>
<li><a href="https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data">INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data</a></li>
</references>
</qhelp>
